<!doctype html>
<html lang="ar">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Strike Force â€” Ù†Ø³Ø®Ø© HTML/JS</title>
<style>
  :root{
    --bg:#08121a; --panel:#0f1720; --accent:#ff4d4d; --text:#eaf6ff;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Tahoma,Arial,system-ui;background:linear-gradient(180deg,#041018,#07131a);color:var(--text)}
  .wrap{display:flex;gap:12px;padding:12px;align-items:flex-start}
  canvas{background:#071927;border-radius:8px;box-shadow:0 8px 30px rgba(0,0,0,.6)}
  #hud{width:320px;padding:12px;background:rgba(255,255,255,.02);border-radius:8px}
  h1{margin:4px 0 10px;font-size:18px}
  .stat{margin:8px 0;padding:8px;background:rgba(255,255,255,.02);border-radius:6px}
  .small{font-size:13px;color:#9fb0c8}
  .btn{background:transparent;border:1px solid rgba(255,255,255,.06);padding:8px;border-radius:6px;color:var(--text);cursor:pointer}
  .row{display:flex;gap:8px;align-items:center}
  footer{font-size:12px;color:#9fb0c8;margin-top:10px}
  .center{display:flex;justify-content:center;align-items:center}
  @media(max-width:980px){.wrap{flex-direction:column;align-items:center}#hud{width:100%}}
</style>
</head>

<body>
<div class="wrap">
  <canvas id="game" width="1000" height="640"></canvas>
  <div id="hud">
    <h1>Strike Force</h1>
    <div class="stat">
      <div>â¤ï¸ HP: <b id="hp">100</b></div>
      <div style="margin-top:6px">Ø¨Ø±Ø¨Ø±: <b id="weap">Pistol</b></div>
      <div style="margin-top:6px">Ø°Ø®ÙŠØ±Ø© : <b id="mag">12</b>/<b id="res">120</b></div>
      <div style="margin-top:6px">Score: <b id="score">0</b> â€” Ù…ÙˆØ¬Ø©: <b id="wave">1</b></div>
      <div style="margin-top:8px" class="small">W A S D Ø­Ø±ÙƒØ© â€” Ù…Ø§ÙˆØ³ ØªØµÙˆÙŠØ¨ â€” Ø§Ù†Ù‚Ø± Ù„Ø¥Ø·Ù„Ø§Ù‚ â€” R relode  â€” Q/E ØªØ¨Ø¯ÙŠÙ„ â€” Shift Ù„Ù„Ø¬Ø±ÙŠ</div>
    </div>

    <div class="stat">
      <div class="row"><button id="restart" class="btn">Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„</button><button id="mute" class="btn">ÙƒØªÙ…/ØªØ´ØºÙŠÙ„ ØµÙˆØª</button></div>
    </div>

    <div class="stat center">
      <canvas id="minimap" width="250" height="250" style="border-radius:6px;background:#04151a"></canvas>
    </div>

    <footer>ØµÙ†Ø¹ Ø¨ÙˆØ§Ø³Ø·Ø© ÙƒÙ„Ø§ Ø®Ø§Ù†Ø² ğŸ˜€</footer>
  </div>
</div>

<script>
/* -------------------------
  Strike Force â€” HTML/JS
  Single-file playable demo
   Controls:
   - WASD movement
   - Mouse aim
   - Hold mouse to fire
   - R reload, Q/E swap
   - Shift sprint
-------------------------*/

// canvas + hi-dpi
const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
const minimap = document.getElementById('minimap'), mctx = minimap.getContext('2d');
let W = canvas.width, H = canvas.height;
function resizeCanvas(){ const ratio = devicePixelRatio || 1; const cssW = Math.min(window.innerWidth - 380, 1100); canvas.style.width = cssW+'px'; canvas.style.height = (cssW*0.64)+'px'; canvas.width = Math.floor(cssW * ratio); canvas.height = Math.floor(cssW*0.64 * ratio); W = canvas.width; H = canvas.height; }
window.addEventListener('resize', resizeCanvas); resizeCanvas();

// HUD elements
const hpEl = document.getElementById('hp'), weapEl = document.getElementById('weap'),
      magEl = document.getElementById('mag'), resEl = document.getElementById('res'),
      scoreEl = document.getElementById('score'), waveEl = document.getElementById('wave'),
      restartBtn = document.getElementById('restart'), muteBtn = document.getElementById('mute');

let muted = false;
muteBtn.addEventListener('click', ()=>{ muted = !muted; muteBtn.textContent = muted ? 'ØªØ´ØºÙŠÙ„ ØµÙˆØª' : 'ÙƒØªÙ…/ØªØ´ØºÙŠÙ„ ØµÙˆØª'; });

// simple audio (WebAudio beeps)
const AC = window.AudioContext || window.webkitAudioContext;
const audioCtx = AC ? new AC() : null;
function playTone(freq, time=0.06){ if(!audioCtx || muted) return; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = 'sine'; o.frequency.value = freq; g.gain.value = 0.03; o.connect(g); g.connect(audioCtx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time); setTimeout(()=>o.stop(), time*1000+30); }

// world
const MAP = {w:2200, h:1400}; // big map (px)
const obstacles = [];
function addObs(x,y,w,h){ obstacles.push({x,y,w,h}); }
for(let i=0;i<50;i++){ const ow = 80 + Math.random()*240, oh = 60 + Math.random()*160; addObs(Math.random()*(MAP.w-ow), Math.random()*(MAP.h-oh), ow, oh); }

// player
const player = {
  x: MAP.w/2, y: MAP.h/2, r:20, speed:4.1, hp:100,
  weapIndex:0, xp:0
};

// weapons
const WEPS = [
  {id:'pistol', name:'Pistol', dmg:200000, mag:120000, res:120, rate:250, speed:11, spread:0.06},
  {id:'smg', name:'SMG', dmg:8, mag:30, res:180, rate:80, speed:14, spread:0.12},
  {id:'shotgun', name:'Shotgun', dmg:28, mag:6, res:30, rate:700, speed:9, spread:0.3}
];
WEPS.forEach(w=> w.cur = w.mag);

// bullets & enemies & loot
let bullets = [], enemies = [], loots = [];
let score = 0, wave = 1, spawnTimer = 0, spawnInterval = 200; // ms

// input
const keys = {}; let mouse = {x:0,y:0,down:false};
window.addEventListener('keydown', e => { keys[e.key] = true; if(e.key==='r' || e.key==='R') reloadWeapon(); if(e.key==='q'||e.key==='Q') switchWeap(-1); if(e.key==='e'||e.key==='E') switchWeap(1); if(e.key==='Shift') player.sprint=true; });
window.addEventListener('keyup', e => { keys[e.key] = false; if(e.key==='Shift') player.sprint=false; });
canvas.addEventListener('mousemove', e => { const r = canvas.getBoundingClientRect(); mouse.x = (e.clientX - r.left) * (canvas.width / r.width); mouse.y = (e.clientY - r.top) * (canvas.height / r.height); });
canvas.addEventListener('mousedown', e => { mouse.down = true; if(audioCtx) audioCtx.resume(); });
canvas.addEventListener('mouseup', e => mouse.down = false);
restartBtn.addEventListener('click', ()=> location.reload());

// helpers
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function dist(ax,ay,bx,by){ return Math.hypot(ax-bx, ay-by); }
function rectCircleColl(rx,ry,rw,rh,cx,cy,cr){
  const closestX = clamp(cx, rx, rx+rw), closestY = clamp(cy, ry, ry+rh);
  const dx = cx-closestX, dy = cy-closestY; return dx*dx + dy*dy < cr*cr;
}

// spawn enemy
function spawnEnemy(){
  // spawn at map edges
  const side = Math.floor(Math.random()*4);
  let x = 0, y = 0;
  enemies.push({x,y,r:12,hp:40 + Math.floor(Math.random()*0) + wave*1, speed:1.2 + Math.random()*0.8 + wave*0.05, cooldown: 400 + Math.random()*800});
}

// spawn loot
function spawnLoot(x,y){
  if(Math.random() < 0.65) loots.push({x,y,type:'ammo',amt: 10 + Math.floor(Math.random()*30)}); else loots.push({x,y,type:'med',amt: 18 + Math.floor(Math.random()*25)});
}

// weapon functions
function currentWeap(){ return WEPS[player.weapIndex]; }
function switchWeap(dir){
  player.weapIndex = (player.weapIndex + dir + WEPS.length) % WEPS.length;
  playTone(800, 0.05);
}
function reloadWeapon(){
  const w = currentWeap();
  const need = w.mag - w.cur;
  if(need <= 0) return;
  const take = Math.min(need, w.res);
  if(take<=0){ playTone(300,0.08); return; }
  // simple reload delay
  playTone(500,0.08);
  setTimeout(()=>{ w.cur += take; w.res -= take; }, 600);
}

// shooting
function tryFire(){
  const w = currentWeap();
  const now = performance.now();
  if(!w._last) w._last = 0;


  w._last = now;
  w.cur--;
  // shotgun fires multiple pellets
  if(w.id === 'shotgun'){
    const pellets = 600;
    for(let i=0;i<pellets;i++){
      const spread = (Math.random()*200-1) * w.spread;
      const angle = Math.atan2(mouse.y - H/2, mouse.x - W/2) + spread;
      bullets.push({x:player.x + Math.cos(angle)*player.r, y:player.y + Math.sin(angle)*player.r, vx:Math.cos(angle)*w.speed, vy:Math.sin(angle)*w.speed, dmg: Math.floor(w.dmg/2), life: 900});
    }
  } else {
    const angle = Math.atan2(mouse.y - H/2, mouse.x - W/2);
    bullets.push({x:player.x + Math.cos(angle)*player.r, y:player.y + Math.sin(angle)*player.r, vx:Math.cos(angle)*w.speed, vy:Math.sin(angle)*w.speed, dmg: w.dmg, life: 1200});
  }
  playTone(1200,0.03);
}

// main update loop
let last = performance.now();
function update(){
  const now = performance.now();
  const dt = Math.min(40, now - last); last = now;

  // player movement
  let mv = player.speed * (player.sprint ? 1.6 : 1);
  if(keys['w'] || keys['W'] || keys['ArrowUp']) player.y -= mv * dt/16;
  if(keys['s'] || keys['S'] || keys['ArrowDown']) player.y += mv * dt/16;
  if(keys['a'] || keys['A'] || keys['ArrowLeft']) player.x -= mv * dt/16;
  if(keys['d'] || keys['D'] || keys['ArrowRight']) player.x += mv * dt/16;
  player.x = clamp(player.x, 10, MAP.w-10); player.y = clamp(player.y, 10, MAP.h-10);

  // shooting
  if(mouse.down) tryFire();

  // bullets update & collision
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.x += b.vx * dt/16; b.y += b.vy * dt/16; b.life -= dt;
    // obstacle collision
    let removed=false;
    for(const ob of obstacles){
      if(rectCircleColl(ob.x, ob.y, ob.w, ob.h, b.x, b.y, 3)){ bullets.splice(i,1); removed=true; break; }
    }
    if(removed) continue;
    if(b.x < 0 || b.x > MAP.w || b.y < 0 || b.y > MAP.h || b.life <= 0){ bullets.splice(i,1); continue; }
    // enemy hit
    for(let j=enemies.length-1;j>=0;j--){
      const e = enemies[j];
      if(dist(b.x,b.y,e.x,e.y) < e.r + 3){
        e.hp -= b.dmg;
        bullets.splice(i,1);
        if(e.hp <= 0){
          // enemy killed
          spawnLoot(e.x, e.y);
          score += 10;
          enemies.splice(j,1);
          playTone(900,0.05);
        }
        break;
      }
    }
  }

  // enemies update
  for(const e of enemies){
    // simple AI: move toward player and occasionally shoot a bullet toward player
    const d = dist(player.x, player.y, e.x, e.y);
    const ang = Math.atan2(player.y - e.y, player.x - e.x);
    if(d > 80) { e.x += Math.cos(ang) * e.speed * dt/16; e.y += Math.sin(ang) * e.speed * dt/16; }
    // random obstacle avoidance simple
    for(const ob of obstacles){
      if(rectCircleColl(ob.x,ob.y,ob.w,ob.h, e.x, e.y, e.r)){
        // nudge away
        e.x += (Math.random()*2-1)*4; e.y += (Math.random()*2-1)*4;
      }
    }
    // shooting
    e.cooldown -= dt;
    if(e.cooldown <= 0 && d < 240){
      e.cooldown = 700 + Math.random()*900;
      // enemy bullet
      bullets.push({x: e.x + Math.cos(ang)*e.r, y: e.y + Math.sin(ang)*e.r, vx: Math.cos(ang)*8, vy: Math.sin(ang)*8, dmg: 10, life: 800, owner:'enemy'});
    }
  }

  // bullets hitting player
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    if(b.owner === 'enemy' && dist(b.x,b.y, player.x, player.y) < player.r + 3){
      player.hp -= b.dmg * 0.5;
      bullets.splice(i,1);
      playTone(300,0.02);
    }
  }

  // collect loot
  for(let i=loots.length-1;i>=0;i--){
    const l = loots[i];
    if(dist(l.x,l.y, player.x, player.y) < player.r + 10){
      if(l.type === 'ammo'){ WEPS.forEach(w=> w.res += l.amt); }
      else { player.hp = Math.min(100, player.hp + l.amt); }
      loots.splice(i,1); playTone(1200,0.04);
    }
  }

  // spawn waves
  spawnTimer -= dt;
  if(spawnTimer <= 0){
    // spawn wave enemies based on wave number
    const count = 3 + Math.floor(wave * 1.2);
    for(let i=0;i<1;i++) spawnEnemy();
    spawnTimer = Math.max(1200, spawnInterval - wave*80);
    wave++;
  }

  // zone: simple shrinking that damages outside area
  // center is map center; radius reduces slowly per wave
  const zoneCenter = {x: MAP.w/2, y: MAP.h/2};
  const baseRadius = Math.min(MAP.w, MAP.h) * 0.45;
  const zoneRadius = Math.max(120, baseRadius - (wave-2)*40);
  const dplayer = dist(player.x, player.y, zoneCenter.x, zoneCenter.y);
  if(dplayer > zoneRadius) player.hp -= 0.06 * dt/16;

  // game over?
  if(player.hp <= 0){
    player.hp = 0;
    // show overlay and stop game loop by flagging stopped
    gameOver = true;
  }

  // update HUD values
  hpEl.textContent = Math.max(0, Math.floor(player.hp));
  const cw = currentWeap();
  weapEl.textContent = cw.name;
  magEl.textContent = cw.cur;
  resEl.textContent = cw.res;
  scoreEl.textContent = score;
  waveEl.textContent = wave-1;
}

// draw
// draw
let gameOver = false;
function draw(){
  // clear
  ctx.clearRect(0,0,W,H);
  const cam = {x: player.x - W/2, y: player.y - H/2};

  // draw map bg
  ctx.fillStyle = '#071927'; 
  ctx.fillRect(-cam.x, -cam.y, MAP.w, MAP.h);

  // draw obstacles
  ctx.fillStyle = '#22363b'; 
  for(const ob of obstacles){
    ctx.fillRect(ob.x - cam.x, ob.y - cam.y, ob.w, ob.h);
    ctx.strokeStyle = 'rgba(0,0,0,0.2)'; 
    ctx.strokeRect(ob.x - cam.x, ob.y - cam.y, ob.w, ob.h);
  }

  // ===== Ù‡Ù†Ø§ Ù†Ø±Ø³Ù… Ø§Ù„Ø²ÙˆÙ† =====
  const zoneCenter = {x: MAP.w/2, y: MAP.h/2};
  const baseRadius = Math.min(MAP.w, MAP.h) * 0.45;
  // ÙŠÙ‚Ù„ ØªØ¯Ø±ÙŠØ¬ÙŠØ§Ù‹ ÙƒÙ„ Ù…ÙˆØ¬Ø©
  const zoneRadius = Math.max(120, baseRadius - (wave-2)*3);
  ctx.beginPath();
  ctx.arc(zoneCenter.x - cam.x, zoneCenter.y - cam.y, zoneRadius, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(0,0,0,0)'; // Ù„ÙˆÙ† Ø£Ø²Ø±Ù‚ Ø´ÙØ§Ù
  ctx.fill();
  ctx.strokeStyle = 'rgba(0, 162, 255, 0.7)';
  ctx.lineWidth = 3;
  ctx.stroke();
  // ==========================

  // draw loots
  for(const l of loots){
    ctx.beginPath();
    ctx.fillStyle = l.type === 'ammo' ? '#ffb703' : '#34d399';
    ctx.arc(l.x - cam.x, l.y - cam.y, 8, 0, Math.PI*2); 
    ctx.fill();
  }

  // draw enemies
  for(const e of enemies){
    ctx.beginPath();
    ctx.fillStyle = '#ef4444';
    ctx.arc(e.x - cam.x, e.y - cam.y, e.r, 0, Math.PI*2); 
    ctx.fill();
    // hp bar
    ctx.fillStyle = '#000'; 
    ctx.fillRect(e.x - cam.x - 12, e.y - cam.y - e.r - 8, 24, 4);
    ctx.fillStyle = '#10b981'; 
    ctx.fillRect(e.x - cam.x - 12, e.y - cam.y - e.r - 8, 24 * Math.max(0, e.hp) / 120, 4);
  }

  // draw bullets
  ctx.fillStyle = '#ffd166';
  for(const b of bullets){ 
    ctx.beginPath(); 
    ctx.arc(b.x - cam.x, b.y - cam.y, 3, 0, Math.PI*2); 
    ctx.fill(); 
  }

  // draw player
  ctx.beginPath(); 
  ctx.fillStyle = '#60a5fa'; 
  ctx.arc(player.x - cam.x, player.y - cam.y, player.r, 0, Math.PI*2); 
  ctx.fill();

  // draw aiming reticle
  const aimAngle = Math.atan2(mouse.y - H/2, mouse.x - W/2);
  ctx.strokeStyle = '#fff';
  ctx.beginPath(); 
  ctx.arc(player.x - cam.x + Math.cos(aimAngle)*40, player.y - cam.y + Math.sin(aimAngle)*40, 6, 0, Math.PI*2); 
  ctx.stroke();

  // mini map
  drawMiniMap();

  // game over overlay
  if(gameOver){
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff'; ctx.font = '48px Tahoma'; ctx.textAlign = 'center'; 
    ctx.fillText('Game Over', W/2, H/2 - 20);
    ctx.font = '20px Tahoma'; 
    ctx.fillText('Ø§Ø¶ØºØ· Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„ Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨', W/2, H/2 + 20);
  }
}


// minimap draw
function drawMiniMap(){
  const mmW = minimap.width, mmH = minimap.height;
  mctx.clearRect(0,0,mmW,mmH);
  mctx.fillStyle = '#04151a'; mctx.fillRect(0,0,mmW,mmH);
  // obstacles tiny
  mctx.fillStyle = '#254';
  for(const ob of obstacles) mctx.fillRect((ob.x/MAP.w)*mmW, (ob.y/MAP.h)*mmH, Math.max(1, (ob.w/MAP.w)*mmW), Math.max(1, (ob.h/MAP.h)*mmH));
  // enemies
  mctx.fillStyle = '#f55'; for(const e of enemies) mctx.fillRect((e.x/MAP.w)*mmW-2, (e.y/MAP.h)*mmH-2, 4,4);
  // player
  mctx.fillStyle = '#6bf'; mctx.fillRect((player.x/MAP.w)*mmW-3, (player.y/MAP.h)*mmH-3, 6,6);
}

// current weapon helper
function currentWeap(){ return WEPS[player.weapIndex]; }

// game loop
function loop(){
  if(!gameOver) update();
  draw();
  requestAnimationFrame(loop);
}
loop();

// initial spawn
for(let i=0;i<4;i++) spawnEnemy();

// expose some functions for dev console
window._game = {player, WEPS, enemies, bullets, loots, spawnEnemy, spawnLoot};

// helpful tips: clicking the canvas will resume audio on some browsers
canvas.addEventListener('click', ()=>{ if(audioCtx) audioCtx.resume(); });

</script>
</body>
</html>
